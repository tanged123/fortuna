{"ast":null,"code":"import Papa from'papaparse';export class CSVStandardizer{/**\n   * Standardizes CSV data by detecting headers and normalizing the structure\n   */static standardizeCSV(csvContent){const results=Papa.parse(csvContent,{header:false,skipEmptyLines:true,transform:value=>(value===null||value===void 0?void 0:value.trim())||'',// Handle quoted values properly\nquotes:true,quoteChar:'\"',escapeChar:'\"'});const data=results.data;if(data.length===0){return{headers:[],rows:[],rawData:[]};}// Detect header row (usually first non-empty row)\nconst headerRow=this.detectHeaderRow(data);const headers=this.normalizeHeaders(data[headerRow]||[]);// Extract data rows\nconst dataRows=data.slice(headerRow+1);const rows=dataRows.map(row=>{const rowObj={};headers.forEach((header,index)=>{rowObj[header]=row[index]||'';});return rowObj;});return{headers,rows,rawData:data};}/**\n   * Detects which row contains the headers\n   */static detectHeaderRow(data){// For most CSVs, the first row is the header\n// But we can also look for patterns that suggest header rows\nlet bestHeaderRow=0;let maxTextScore=0;for(let i=0;i<Math.min(3,data.length);i++){const row=data[i];let textScore=0;for(const cell of row){if(cell&&typeof cell==='string'){// Score based on text characteristics\nif(this.FINANCIAL_PATTERNS.incomePatterns.some(p=>p.test(cell)))textScore+=3;if(this.FINANCIAL_PATTERNS.expensePatterns.some(p=>p.test(cell)))textScore+=2;if(!this.FINANCIAL_PATTERNS.amountPatterns.some(p=>p.test(cell)))textScore+=1;if(cell.length>3&&!/^\\d+$/.test(cell))textScore+=1;// Bonus for common header words\nif(/date|category|amount|description|type/i.test(cell))textScore+=2;}}if(textScore>maxTextScore){maxTextScore=textScore;bestHeaderRow=i;}}return bestHeaderRow;}/**\n   * Normalizes headers to standard format\n   */static normalizeHeaders(headers){return headers.map((header,index)=>{if(!header||header.trim()===''){return\"column_\".concat(index+1);}// Clean and normalize header\nlet normalized=header.toLowerCase().replace(/[^\\w\\s]/g,'').replace(/\\s+/g,'_').trim();// Map common variations to standard names\nconst headerMappings={'booba_money':'category','booboo_moeny':'amount','baobooboo_money':'running_total','date':'date','description':'description','category':'category','amount':'amount','value':'amount','cost':'amount','price':'amount'};return headerMappings[normalized]||normalized;});}/**\n   * Extracts financial data from standardized CSV\n   */static extractFinancialData(standardizedData){const{headers,rows}=standardizedData;// Find income data\nconst monthlyNetIncome=this.extractIncome(rows,headers);// Find expense data\nconst expenses=this.extractExpenses(rows,headers);const totalExpenses=expenses.reduce((sum,expense)=>sum+expense.amount,0);// Calculate savings\nconst savings=monthlyNetIncome-totalExpenses;const savingsPercentage=monthlyNetIncome>0?savings/monthlyNetIncome*100:0;// Find annual return\nconst annualReturn=this.extractAnnualReturn(rows,headers);return{monthlyNetIncome,expenses,totalExpenses,savings,savingsPercentage,annualReturn};}/**\n   * Extracts income information from CSV rows\n   */static extractIncome(rows,headers){// Look for income-related rows\nfor(let i=0;i<rows.length;i++){const row=rows[i];for(const[,value]of Object.entries(row)){if(this.FINANCIAL_PATTERNS.incomePatterns.some(pattern=>pattern.test(value))){// Look for amount in the same row first\nconst amount=this.findAmountInRow(row,headers);if(amount>0)return amount;// Check next row if current row doesn't have amount\nif(i+1<rows.length){const nextRow=rows[i+1];const nextAmount=this.findAmountInRow(nextRow,headers);if(nextAmount>0)return nextAmount;}}}}return 0;}/**\n   * Extracts expense information from CSV rows\n   */static extractExpenses(rows,headers){const expenses=[];for(const row of rows){// Look for expense categories in any column\nfor(const[,value]of Object.entries(row)){if(value&&this.isExpenseCategory(value)){// Found an expense category, look for amount in the same row\nconst amount=this.findAmountInRow(row,headers);if(amount>0){expenses.push({category:value.trim(),amount});}}}}return expenses;}/**\n   * Extracts annual return percentage\n   */static extractAnnualReturn(rows,headers){for(const row of rows){for(const[,value]of Object.entries(row)){if(/annual.*return|return.*annual/i.test(value)){const amount=this.findAmountInRow(row,headers);if(amount>0)return amount;}}}return 7;// Default 7% return\n}/**\n   * Finds category/description in a row\n   */static findCategoryInRow(row,headers){for(const[,value]of Object.entries(row)){if(value&&!this.FINANCIAL_PATTERNS.amountPatterns.some(p=>p.test(value))&&!this.FINANCIAL_PATTERNS.datePatterns.some(p=>p.test(value))&&value.length>1){return value.trim();}}return null;}/**\n   * Finds amount in a row\n   */static findAmountInRow(row,headers){for(const[,value]of Object.entries(row)){if(value&&this.FINANCIAL_PATTERNS.amountPatterns.some(p=>p.test(value))){const cleaned=value.replace(/[$,%\\s]/g,'');const parsed=parseFloat(cleaned);if(!isNaN(parsed)){return parsed;}}}// Also check for amounts that might be in the same cell as text\nfor(const[,value]of Object.entries(row)){if(value){// Look for dollar amounts in the text\nconst dollarMatch=value.match(/\\$\\s*[\\d,]+\\.?\\d*/);if(dollarMatch){const cleaned=dollarMatch[0].replace(/[$,%\\s]/g,'');const parsed=parseFloat(cleaned);if(!isNaN(parsed)){return parsed;}}}}return 0;}/**\n   * Checks if a category is an expense category\n   */static isExpenseCategory(category){return this.FINANCIAL_PATTERNS.expensePatterns.some(pattern=>pattern.test(category));}/**\n   * Validates and cleans CSV content\n   */static validateAndCleanCSV(csvContent){const errors=[];let cleanedContent=csvContent;try{// Basic validation\nif(!csvContent||csvContent.trim().length===0){errors.push('CSV content is empty');return{isValid:false,cleanedContent:'',errors};}// Try to parse and re-serialize to clean up formatting\nconst results=Papa.parse(csvContent,{header:false,skipEmptyLines:true,transform:value=>(value===null||value===void 0?void 0:value.trim())||''});if(results.errors.length>0){errors.push(...results.errors.map(e=>e.message));}// Re-serialize to ensure consistent formatting\ncleanedContent=Papa.unparse(results.data);return{isValid:errors.length===0,cleanedContent,errors};}catch(error){errors.push(\"Failed to parse CSV: \".concat(error instanceof Error?error.message:'Unknown error'));return{isValid:false,cleanedContent:'',errors};}}}CSVStandardizer.FINANCIAL_PATTERNS={incomePatterns:[/income/i,/salary/i,/wage/i,/earnings/i,/revenue/i,/net income/i,/monthly income/i,/annual income/i,/gross income/i,/take home/i],expensePatterns:[/expense/i,/cost/i,/spending/i,/payment/i,/bill/i,/rent/i,/utilities/i,/groceries/i,/food/i,/restaurant/i,/gas/i,/auto/i,/car/i,/medical/i,/health/i,/gym/i,/travel/i,/shopping/i,/entertainment/i,/fun/i,/misc/i,/miscellaneous/i],amountPatterns:[/^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*$/,/^\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/,/^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/],datePatterns:[/^\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}$/,/^\\d{4}-\\d{1,2}-\\d{1,2}$/,/^\\d{1,2}-\\d{1,2}-\\d{2,4}$/]};","map":{"version":3,"names":["Papa","CSVStandardizer","standardizeCSV","csvContent","results","parse","header","skipEmptyLines","transform","value","trim","quotes","quoteChar","escapeChar","data","length","headers","rows","rawData","headerRow","detectHeaderRow","normalizeHeaders","dataRows","slice","map","row","rowObj","forEach","index","bestHeaderRow","maxTextScore","i","Math","min","textScore","cell","FINANCIAL_PATTERNS","incomePatterns","some","p","test","expensePatterns","amountPatterns","concat","normalized","toLowerCase","replace","headerMappings","extractFinancialData","standardizedData","monthlyNetIncome","extractIncome","expenses","extractExpenses","totalExpenses","reduce","sum","expense","amount","savings","savingsPercentage","annualReturn","extractAnnualReturn","Object","entries","pattern","findAmountInRow","nextRow","nextAmount","isExpenseCategory","push","category","findCategoryInRow","datePatterns","cleaned","parsed","parseFloat","isNaN","dollarMatch","match","validateAndCleanCSV","errors","cleanedContent","isValid","e","message","unparse","error","Error"],"sources":["/home/tanged/repo/Fortuna/src/utils/csvStandardizer.ts"],"sourcesContent":["import Papa from 'papaparse';\nimport { ParsedFinancialData, Expense } from '../types/finance';\n\nexport interface StandardizedCSVData {\n  headers: string[];\n  rows: Record<string, string>[];\n  rawData: any[];\n}\n\nexport interface FinancialDataPattern {\n  incomePatterns: RegExp[];\n  expensePatterns: RegExp[];\n  amountPatterns: RegExp[];\n  datePatterns: RegExp[];\n}\n\nexport class CSVStandardizer {\n  private static readonly FINANCIAL_PATTERNS: FinancialDataPattern = {\n    incomePatterns: [\n      /income/i,\n      /salary/i,\n      /wage/i,\n      /earnings/i,\n      /revenue/i,\n      /net income/i,\n      /monthly income/i,\n      /annual income/i,\n      /gross income/i,\n      /take home/i\n    ],\n    expensePatterns: [\n      /expense/i,\n      /cost/i,\n      /spending/i,\n      /payment/i,\n      /bill/i,\n      /rent/i,\n      /utilities/i,\n      /groceries/i,\n      /food/i,\n      /restaurant/i,\n      /gas/i,\n      /auto/i,\n      /car/i,\n      /medical/i,\n      /health/i,\n      /gym/i,\n      /travel/i,\n      /shopping/i,\n      /entertainment/i,\n      /fun/i,\n      /misc/i,\n      /miscellaneous/i\n    ],\n    amountPatterns: [\n      /^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*$/,\n      /^\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/,\n      /^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/\n    ],\n    datePatterns: [\n      /^\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}$/,\n      /^\\d{4}-\\d{1,2}-\\d{1,2}$/,\n      /^\\d{1,2}-\\d{1,2}-\\d{2,4}$/\n    ]\n  };\n\n  /**\n   * Standardizes CSV data by detecting headers and normalizing the structure\n   */\n  static standardizeCSV(csvContent: string): StandardizedCSVData {\n    const results = Papa.parse<string[]>(csvContent, {\n      header: false,\n      skipEmptyLines: true,\n      transform: (value: string) => value?.trim() || '',\n      // Handle quoted values properly\n      quotes: true,\n      quoteChar: '\"',\n      escapeChar: '\"'\n    });\n\n    const data = results.data;\n    \n    if (data.length === 0) {\n      return { headers: [], rows: [], rawData: [] };\n    }\n\n    // Detect header row (usually first non-empty row)\n    const headerRow = this.detectHeaderRow(data);\n    const headers = this.normalizeHeaders(data[headerRow] || []);\n    \n    // Extract data rows\n    const dataRows = data.slice(headerRow + 1);\n    const rows = dataRows.map(row => {\n      const rowObj: Record<string, string> = {};\n      headers.forEach((header, index) => {\n        rowObj[header] = row[index] || '';\n      });\n      return rowObj;\n    });\n\n    return {\n      headers,\n      rows,\n      rawData: data\n    };\n  }\n\n  /**\n   * Detects which row contains the headers\n   */\n  private static detectHeaderRow(data: string[][]): number {\n    // For most CSVs, the first row is the header\n    // But we can also look for patterns that suggest header rows\n    let bestHeaderRow = 0;\n    let maxTextScore = 0;\n\n    for (let i = 0; i < Math.min(3, data.length); i++) {\n      const row = data[i];\n      let textScore = 0;\n      \n      for (const cell of row) {\n        if (cell && typeof cell === 'string') {\n          // Score based on text characteristics\n          if (this.FINANCIAL_PATTERNS.incomePatterns.some(p => p.test(cell))) textScore += 3;\n          if (this.FINANCIAL_PATTERNS.expensePatterns.some(p => p.test(cell))) textScore += 2;\n          if (!this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(cell))) textScore += 1;\n          if (cell.length > 3 && !/^\\d+$/.test(cell)) textScore += 1;\n          // Bonus for common header words\n          if (/date|category|amount|description|type/i.test(cell)) textScore += 2;\n        }\n      }\n      \n      if (textScore > maxTextScore) {\n        maxTextScore = textScore;\n        bestHeaderRow = i;\n      }\n    }\n\n    return bestHeaderRow;\n  }\n\n  /**\n   * Normalizes headers to standard format\n   */\n  private static normalizeHeaders(headers: string[]): string[] {\n    return headers.map((header, index) => {\n      if (!header || header.trim() === '') {\n        return `column_${index + 1}`;\n      }\n      \n      // Clean and normalize header\n      let normalized = header.toLowerCase()\n        .replace(/[^\\w\\s]/g, '')\n        .replace(/\\s+/g, '_')\n        .trim();\n      \n      // Map common variations to standard names\n      const headerMappings: Record<string, string> = {\n        'booba_money': 'category',\n        'booboo_moeny': 'amount',\n        'baobooboo_money': 'running_total',\n        'date': 'date',\n        'description': 'description',\n        'category': 'category',\n        'amount': 'amount',\n        'value': 'amount',\n        'cost': 'amount',\n        'price': 'amount'\n      };\n      \n      return headerMappings[normalized] || normalized;\n    });\n  }\n\n  /**\n   * Extracts financial data from standardized CSV\n   */\n  static extractFinancialData(standardizedData: StandardizedCSVData): ParsedFinancialData {\n    const { headers, rows } = standardizedData;\n    \n    // Find income data\n    const monthlyNetIncome = this.extractIncome(rows, headers);\n    \n    // Find expense data\n    const expenses = this.extractExpenses(rows, headers);\n    const totalExpenses = expenses.reduce((sum, expense) => sum + expense.amount, 0);\n    \n    // Calculate savings\n    const savings = monthlyNetIncome - totalExpenses;\n    const savingsPercentage = monthlyNetIncome > 0 ? (savings / monthlyNetIncome) * 100 : 0;\n    \n    // Find annual return\n    const annualReturn = this.extractAnnualReturn(rows, headers);\n    \n    return {\n      monthlyNetIncome,\n      expenses,\n      totalExpenses,\n      savings,\n      savingsPercentage,\n      annualReturn\n    };\n  }\n\n  /**\n   * Extracts income information from CSV rows\n   */\n  private static extractIncome(rows: Record<string, string>[], headers: string[]): number {\n    // Look for income-related rows\n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      for (const [, value] of Object.entries(row)) {\n        if (this.FINANCIAL_PATTERNS.incomePatterns.some(pattern => pattern.test(value))) {\n          // Look for amount in the same row first\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) return amount;\n          \n          // Check next row if current row doesn't have amount\n          if (i + 1 < rows.length) {\n            const nextRow = rows[i + 1];\n            const nextAmount = this.findAmountInRow(nextRow, headers);\n            if (nextAmount > 0) return nextAmount;\n          }\n        }\n      }\n    }\n    \n    return 0;\n  }\n\n  /**\n   * Extracts expense information from CSV rows\n   */\n  private static extractExpenses(rows: Record<string, string>[], headers: string[]): Expense[] {\n    const expenses: Expense[] = [];\n    \n    for (const row of rows) {\n      // Look for expense categories in any column\n      for (const [, value] of Object.entries(row)) {\n        if (value && this.isExpenseCategory(value)) {\n          // Found an expense category, look for amount in the same row\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) {\n            expenses.push({ category: value.trim(), amount });\n          }\n        }\n      }\n    }\n    \n    return expenses;\n  }\n\n  /**\n   * Extracts annual return percentage\n   */\n  private static extractAnnualReturn(rows: Record<string, string>[], headers: string[]): number {\n    for (const row of rows) {\n      for (const [, value] of Object.entries(row)) {\n        if (/annual.*return|return.*annual/i.test(value)) {\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) return amount;\n        }\n      }\n    }\n    \n    return 7; // Default 7% return\n  }\n\n  /**\n   * Finds category/description in a row\n   */\n  private static findCategoryInRow(row: Record<string, string>, headers: string[]): string | null {\n    for (const [, value] of Object.entries(row)) {\n      if (value && \n          !this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(value)) &&\n          !this.FINANCIAL_PATTERNS.datePatterns.some(p => p.test(value)) &&\n          value.length > 1) {\n        return value.trim();\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Finds amount in a row\n   */\n  private static findAmountInRow(row: Record<string, string>, headers: string[]): number {\n    for (const [, value] of Object.entries(row)) {\n      if (value && this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(value))) {\n        const cleaned = value.replace(/[$,%\\s]/g, '');\n        const parsed = parseFloat(cleaned);\n        if (!isNaN(parsed)) {\n          return parsed;\n        }\n      }\n    }\n    \n    // Also check for amounts that might be in the same cell as text\n    for (const [, value] of Object.entries(row)) {\n      if (value) {\n        // Look for dollar amounts in the text\n        const dollarMatch = value.match(/\\$\\s*[\\d,]+\\.?\\d*/);\n        if (dollarMatch) {\n          const cleaned = dollarMatch[0].replace(/[$,%\\s]/g, '');\n          const parsed = parseFloat(cleaned);\n          if (!isNaN(parsed)) {\n            return parsed;\n          }\n        }\n      }\n    }\n    \n    return 0;\n  }\n\n  /**\n   * Checks if a category is an expense category\n   */\n  private static isExpenseCategory(category: string): boolean {\n    return this.FINANCIAL_PATTERNS.expensePatterns.some(pattern => pattern.test(category));\n  }\n\n  /**\n   * Validates and cleans CSV content\n   */\n  static validateAndCleanCSV(csvContent: string): { isValid: boolean; cleanedContent: string; errors: string[] } {\n    const errors: string[] = [];\n    let cleanedContent = csvContent;\n\n    try {\n      // Basic validation\n      if (!csvContent || csvContent.trim().length === 0) {\n        errors.push('CSV content is empty');\n        return { isValid: false, cleanedContent: '', errors };\n      }\n\n      // Try to parse and re-serialize to clean up formatting\n      const results = Papa.parse(csvContent, {\n        header: false,\n        skipEmptyLines: true,\n        transform: (value: string) => value?.trim() || ''\n      });\n\n      if (results.errors.length > 0) {\n        errors.push(...results.errors.map(e => e.message));\n      }\n\n      // Re-serialize to ensure consistent formatting\n      cleanedContent = Papa.unparse(results.data);\n\n      return {\n        isValid: errors.length === 0,\n        cleanedContent,\n        errors\n      };\n    } catch (error) {\n      errors.push(`Failed to parse CSV: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return { isValid: false, cleanedContent: '', errors };\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}