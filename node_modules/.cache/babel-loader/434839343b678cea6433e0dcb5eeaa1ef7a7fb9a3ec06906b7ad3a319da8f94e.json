{"ast":null,"code":"import Papa from'papaparse';export class CSVStandardizer{/**\n   * Standardizes CSV data by detecting headers and normalizing the structure\n   */static standardizeCSV(csvContent){const results=Papa.parse(csvContent,{header:false,skipEmptyLines:true,transform:value=>(value===null||value===void 0?void 0:value.trim())||'',// Handle quoted values properly\nquoteChar:'\"',escapeChar:'\"'});const data=results.data;if(data.length===0){return{headers:[],rows:[],rawData:[]};}// Detect header row (usually first non-empty row)\nconst headerRow=this.detectHeaderRow(data);const headers=this.normalizeHeaders(data[headerRow]||[]);// Extract data rows\nconst dataRows=data.slice(headerRow+1);const rows=dataRows.map(row=>{const rowObj={};headers.forEach((header,index)=>{rowObj[header]=row[index]||'';});return rowObj;});return{headers,rows,rawData:data};}/**\n   * Detects which row contains the headers\n   */static detectHeaderRow(data){// For most CSVs, the first row is the header\n// But we can also look for patterns that suggest header rows\nlet bestHeaderRow=0;let maxTextScore=0;for(let i=0;i<Math.min(3,data.length);i++){const row=data[i];let textScore=0;for(const cell of row){if(cell&&typeof cell==='string'){// Score based on text characteristics\nif(this.FINANCIAL_PATTERNS.incomePatterns.some(p=>p.test(cell)))textScore+=3;if(this.FINANCIAL_PATTERNS.expensePatterns.some(p=>p.test(cell)))textScore+=2;if(!this.FINANCIAL_PATTERNS.amountPatterns.some(p=>p.test(cell)))textScore+=1;if(cell.length>3&&!/^\\d+$/.test(cell))textScore+=1;// Bonus for common header words\nif(/date|category|amount|description|type/i.test(cell))textScore+=2;}}if(textScore>maxTextScore){maxTextScore=textScore;bestHeaderRow=i;}}return bestHeaderRow;}/**\n   * Normalizes headers to standard format\n   */static normalizeHeaders(headers){return headers.map((header,index)=>{if(!header||header.trim()===''){return\"column_\".concat(index+1);}// Clean and normalize header\nlet normalized=header.toLowerCase().replace(/[^\\w\\s]/g,'').replace(/\\s+/g,'_').trim();// Map common variations to standard names\nconst headerMappings={'booba_money':'category','booboo_moeny':'amount','baobooboo_money':'running_total','date':'date','description':'description','category':'category','amount':'amount','value':'amount','cost':'amount','price':'amount'};return headerMappings[normalized]||normalized;});}/**\n   * Extracts financial data from standardized CSV\n   */static extractFinancialData(standardizedData){const{headers,rows}=standardizedData;// Find income data\nconst monthlyNetIncome=this.extractIncome(rows,headers);// Find expense data\nconst expenses=this.extractExpenses(rows,headers);const totalExpenses=expenses.reduce((sum,expense)=>sum+expense.amount,0);// Calculate savings\nconst savings=monthlyNetIncome-totalExpenses;const savingsPercentage=monthlyNetIncome>0?savings/monthlyNetIncome*100:0;// Find annual return\nconst annualReturn=this.extractAnnualReturn(rows,headers);return{monthlyNetIncome,expenses,totalExpenses,savings,savingsPercentage,annualReturn};}/**\n   * Extracts income information from CSV rows\n   */static extractIncome(rows,headers){// Look for income-related rows\nfor(let i=0;i<rows.length;i++){const row=rows[i];for(const[,value]of Object.entries(row)){if(this.FINANCIAL_PATTERNS.incomePatterns.some(pattern=>pattern.test(value))){// Look for amount in the same row first\nconst amount=this.findAmountInRow(row,headers);if(amount>0)return amount;// Check next row if current row doesn't have amount\nif(i+1<rows.length){const nextRow=rows[i+1];const nextAmount=this.findAmountInRow(nextRow,headers);if(nextAmount>0)return nextAmount;}}}}return 0;}/**\n   * Extracts expense information from CSV rows\n   */static extractExpenses(rows,headers){const expenses=[];for(const row of rows){// Look for expense categories in any column\nfor(const[,value]of Object.entries(row)){if(value&&this.isExpenseCategory(value)){// Found an expense category, look for amount in the same row\nconst amount=this.findAmountInRow(row,headers);if(amount>0){const normalizedCategory=this.normalizeExpenseCategory(value.trim());expenses.push({category:normalizedCategory,amount});}}}}return expenses;}/**\n   * Extracts annual return percentage\n   */static extractAnnualReturn(rows,headers){for(const row of rows){for(const[,value]of Object.entries(row)){if(/annual.*return|return.*annual/i.test(value)){const amount=this.findAmountInRow(row,headers);if(amount>0)return amount;}}}return 7;// Default 7% return\n}/**\n   * Finds category/description in a row\n   */static findCategoryInRow(row,headers){for(const[,value]of Object.entries(row)){if(value&&!this.FINANCIAL_PATTERNS.amountPatterns.some(p=>p.test(value))&&!this.FINANCIAL_PATTERNS.datePatterns.some(p=>p.test(value))&&value.length>1){return value.trim();}}return null;}/**\n   * Finds amount in a row\n   */static findAmountInRow(row,headers){for(const[,value]of Object.entries(row)){if(value&&this.FINANCIAL_PATTERNS.amountPatterns.some(p=>p.test(value))){const cleaned=value.replace(/[$,%\\s]/g,'');const parsed=parseFloat(cleaned);if(!isNaN(parsed)){return parsed;}}}// Also check for amounts that might be in the same cell as text\nfor(const[,value]of Object.entries(row)){if(value){// Look for dollar amounts in the text\nconst dollarMatch=value.match(/\\$\\s*[\\d,]+\\.?\\d*/);if(dollarMatch){const cleaned=dollarMatch[0].replace(/[$,%\\s]/g,'');const parsed=parseFloat(cleaned);if(!isNaN(parsed)){return parsed;}}}}return 0;}/**\n   * Checks if a category is an expense category\n   */static isExpenseCategory(category){return this.FINANCIAL_PATTERNS.expensePatterns.some(pattern=>pattern.test(category));}/**\n   * Normalizes expense category names to handle misspellings and variations\n   */static normalizeExpenseCategory(category){const normalized=category.toLowerCase().trim();// Check against known variations\nfor(const[standardName,variations]of Object.entries(this.EXPENSE_VARIATIONS)){if(variations.some(variation=>variation.toLowerCase()===normalized)){return standardName;}}// Try fuzzy matching for close misspellings\nconst fuzzyMatch=this.findFuzzyMatch(normalized);if(fuzzyMatch){return fuzzyMatch;}// If no variation found, return the original category\nreturn category;}/**\n   * Finds fuzzy matches for expense categories using simple string similarity\n   */static findFuzzyMatch(category){const standardCategories=Object.keys(this.EXPENSE_VARIATIONS);for(const standard of standardCategories){if(this.calculateSimilarity(category,standard)>0.8){return standard;}}return null;}/**\n   * Calculates string similarity using Levenshtein distance\n   */static calculateSimilarity(str1,str2){const longer=str1.length>str2.length?str1:str2;const shorter=str1.length>str2.length?str2:str1;if(longer.length===0)return 1.0;const distance=this.levenshteinDistance(longer,shorter);return(longer.length-distance)/longer.length;}/**\n   * Calculates Levenshtein distance between two strings\n   */static levenshteinDistance(str1,str2){const matrix=Array(str2.length+1).fill(null).map(()=>Array(str1.length+1).fill(null));for(let i=0;i<=str1.length;i++)matrix[0][i]=i;for(let j=0;j<=str2.length;j++)matrix[j][0]=j;for(let j=1;j<=str2.length;j++){for(let i=1;i<=str1.length;i++){const indicator=str1[i-1]===str2[j-1]?0:1;matrix[j][i]=Math.min(matrix[j][i-1]+1,// deletion\nmatrix[j-1][i]+1,// insertion\nmatrix[j-1][i-1]+indicator// substitution\n);}}return matrix[str2.length][str1.length];}/**\n   * Validates and cleans CSV content\n   */static validateAndCleanCSV(csvContent){const errors=[];let cleanedContent=csvContent;try{// Basic validation\nif(!csvContent||csvContent.trim().length===0){errors.push('CSV content is empty');return{isValid:false,cleanedContent:'',errors};}// Try to parse and re-serialize to clean up formatting\nconst results=Papa.parse(csvContent,{header:false,skipEmptyLines:true,transform:value=>(value===null||value===void 0?void 0:value.trim())||''});if(results.errors.length>0){errors.push(...results.errors.map(e=>e.message));}// Re-serialize to ensure consistent formatting\ncleanedContent=Papa.unparse(results.data);return{isValid:errors.length===0,cleanedContent,errors};}catch(error){errors.push(\"Failed to parse CSV: \".concat(error instanceof Error?error.message:'Unknown error'));return{isValid:false,cleanedContent:'',errors};}}}CSVStandardizer.FINANCIAL_PATTERNS={incomePatterns:[/income/i,/salary/i,/wage/i,/earnings/i,/revenue/i,/net income/i,/monthly income/i,/annual income/i,/gross income/i,/take home/i],expensePatterns:[/expense/i,/cost/i,/spending/i,/payment/i,/bill/i,/rent/i,/utilities/i,/groceries/i,/food/i,/restaurant/i,/resturant/i,// Handle common misspelling\n/gas/i,/auto/i,/car/i,/medical/i,/health/i,/gym/i,/travel/i,/shopping/i,/entertainment/i,/fun/i,/misc/i,/miscellaneous/i],amountPatterns:[/^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*$/,/^\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/,/^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/],datePatterns:[/^\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}$/,/^\\d{4}-\\d{1,2}-\\d{1,2}$/,/^\\d{1,2}-\\d{1,2}-\\d{2,4}$/]};// Common misspellings and variations for expense categories\nCSVStandardizer.EXPENSE_VARIATIONS={'restaurant':['resturant','restraunt','resturants','restaurants'],'utilities':['utility','utilities'],'groceries':['grocery','groceries','grocery store'],'medical':['medical','health','healthcare','medical/health'],'gas':['gas','fuel','gas/auto','auto','car'],'entertainment':['entertainment','fun','night out','fun / night out'],'miscellaneous':['misc','miscellaneous','misc.','other','others']};","map":{"version":3,"names":["Papa","CSVStandardizer","standardizeCSV","csvContent","results","parse","header","skipEmptyLines","transform","value","trim","quoteChar","escapeChar","data","length","headers","rows","rawData","headerRow","detectHeaderRow","normalizeHeaders","dataRows","slice","map","row","rowObj","forEach","index","bestHeaderRow","maxTextScore","i","Math","min","textScore","cell","FINANCIAL_PATTERNS","incomePatterns","some","p","test","expensePatterns","amountPatterns","concat","normalized","toLowerCase","replace","headerMappings","extractFinancialData","standardizedData","monthlyNetIncome","extractIncome","expenses","extractExpenses","totalExpenses","reduce","sum","expense","amount","savings","savingsPercentage","annualReturn","extractAnnualReturn","Object","entries","pattern","findAmountInRow","nextRow","nextAmount","isExpenseCategory","normalizedCategory","normalizeExpenseCategory","push","category","findCategoryInRow","datePatterns","cleaned","parsed","parseFloat","isNaN","dollarMatch","match","standardName","variations","EXPENSE_VARIATIONS","variation","fuzzyMatch","findFuzzyMatch","standardCategories","keys","standard","calculateSimilarity","str1","str2","longer","shorter","distance","levenshteinDistance","matrix","Array","fill","j","indicator","validateAndCleanCSV","errors","cleanedContent","isValid","e","message","unparse","error","Error"],"sources":["/home/tanged/repo/Fortuna/src/utils/csvStandardizer.ts"],"sourcesContent":["import Papa from 'papaparse';\nimport { ParsedFinancialData, Expense } from '../types/finance';\n\nexport interface StandardizedCSVData {\n  headers: string[];\n  rows: Record<string, string>[];\n  rawData: any[];\n}\n\nexport interface FinancialDataPattern {\n  incomePatterns: RegExp[];\n  expensePatterns: RegExp[];\n  amountPatterns: RegExp[];\n  datePatterns: RegExp[];\n}\n\nexport class CSVStandardizer {\n  private static readonly FINANCIAL_PATTERNS: FinancialDataPattern = {\n    incomePatterns: [\n      /income/i,\n      /salary/i,\n      /wage/i,\n      /earnings/i,\n      /revenue/i,\n      /net income/i,\n      /monthly income/i,\n      /annual income/i,\n      /gross income/i,\n      /take home/i\n    ],\n    expensePatterns: [\n      /expense/i,\n      /cost/i,\n      /spending/i,\n      /payment/i,\n      /bill/i,\n      /rent/i,\n      /utilities/i,\n      /groceries/i,\n      /food/i,\n      /restaurant/i,\n      /resturant/i, // Handle common misspelling\n      /gas/i,\n      /auto/i,\n      /car/i,\n      /medical/i,\n      /health/i,\n      /gym/i,\n      /travel/i,\n      /shopping/i,\n      /entertainment/i,\n      /fun/i,\n      /misc/i,\n      /miscellaneous/i\n    ],\n    amountPatterns: [\n      /^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*$/,\n      /^\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/,\n      /^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/\n    ],\n    datePatterns: [\n      /^\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}$/,\n      /^\\d{4}-\\d{1,2}-\\d{1,2}$/,\n      /^\\d{1,2}-\\d{1,2}-\\d{2,4}$/\n    ]\n  };\n\n  // Common misspellings and variations for expense categories\n  private static readonly EXPENSE_VARIATIONS: Record<string, string[]> = {\n    'restaurant': ['resturant', 'restraunt', 'resturants', 'restaurants'],\n    'utilities': ['utility', 'utilities'],\n    'groceries': ['grocery', 'groceries', 'grocery store'],\n    'medical': ['medical', 'health', 'healthcare', 'medical/health'],\n    'gas': ['gas', 'fuel', 'gas/auto', 'auto', 'car'],\n    'entertainment': ['entertainment', 'fun', 'night out', 'fun / night out'],\n    'miscellaneous': ['misc', 'miscellaneous', 'misc.', 'other', 'others']\n  };\n\n  /**\n   * Standardizes CSV data by detecting headers and normalizing the structure\n   */\n  static standardizeCSV(csvContent: string): StandardizedCSVData {\n    const results = Papa.parse<string[]>(csvContent, {\n      header: false,\n      skipEmptyLines: true,\n      transform: (value: string) => value?.trim() || '',\n      // Handle quoted values properly\n      quoteChar: '\"',\n      escapeChar: '\"'\n    });\n\n    const data = results.data;\n    \n    if (data.length === 0) {\n      return { headers: [], rows: [], rawData: [] };\n    }\n\n    // Detect header row (usually first non-empty row)\n    const headerRow = this.detectHeaderRow(data);\n    const headers = this.normalizeHeaders(data[headerRow] || []);\n    \n    // Extract data rows\n    const dataRows = data.slice(headerRow + 1);\n    const rows = dataRows.map(row => {\n      const rowObj: Record<string, string> = {};\n      headers.forEach((header, index) => {\n        rowObj[header] = row[index] || '';\n      });\n      return rowObj;\n    });\n\n    return {\n      headers,\n      rows,\n      rawData: data\n    };\n  }\n\n  /**\n   * Detects which row contains the headers\n   */\n  private static detectHeaderRow(data: string[][]): number {\n    // For most CSVs, the first row is the header\n    // But we can also look for patterns that suggest header rows\n    let bestHeaderRow = 0;\n    let maxTextScore = 0;\n\n    for (let i = 0; i < Math.min(3, data.length); i++) {\n      const row = data[i];\n      let textScore = 0;\n      \n      for (const cell of row) {\n        if (cell && typeof cell === 'string') {\n          // Score based on text characteristics\n          if (this.FINANCIAL_PATTERNS.incomePatterns.some(p => p.test(cell))) textScore += 3;\n          if (this.FINANCIAL_PATTERNS.expensePatterns.some(p => p.test(cell))) textScore += 2;\n          if (!this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(cell))) textScore += 1;\n          if (cell.length > 3 && !/^\\d+$/.test(cell)) textScore += 1;\n          // Bonus for common header words\n          if (/date|category|amount|description|type/i.test(cell)) textScore += 2;\n        }\n      }\n      \n      if (textScore > maxTextScore) {\n        maxTextScore = textScore;\n        bestHeaderRow = i;\n      }\n    }\n\n    return bestHeaderRow;\n  }\n\n  /**\n   * Normalizes headers to standard format\n   */\n  private static normalizeHeaders(headers: string[]): string[] {\n    return headers.map((header, index) => {\n      if (!header || header.trim() === '') {\n        return `column_${index + 1}`;\n      }\n      \n      // Clean and normalize header\n      let normalized = header.toLowerCase()\n        .replace(/[^\\w\\s]/g, '')\n        .replace(/\\s+/g, '_')\n        .trim();\n      \n      // Map common variations to standard names\n      const headerMappings: Record<string, string> = {\n        'booba_money': 'category',\n        'booboo_moeny': 'amount',\n        'baobooboo_money': 'running_total',\n        'date': 'date',\n        'description': 'description',\n        'category': 'category',\n        'amount': 'amount',\n        'value': 'amount',\n        'cost': 'amount',\n        'price': 'amount'\n      };\n      \n      return headerMappings[normalized] || normalized;\n    });\n  }\n\n  /**\n   * Extracts financial data from standardized CSV\n   */\n  static extractFinancialData(standardizedData: StandardizedCSVData): ParsedFinancialData {\n    const { headers, rows } = standardizedData;\n    \n    // Find income data\n    const monthlyNetIncome = this.extractIncome(rows, headers);\n    \n    // Find expense data\n    const expenses = this.extractExpenses(rows, headers);\n    const totalExpenses = expenses.reduce((sum, expense) => sum + expense.amount, 0);\n    \n    // Calculate savings\n    const savings = monthlyNetIncome - totalExpenses;\n    const savingsPercentage = monthlyNetIncome > 0 ? (savings / monthlyNetIncome) * 100 : 0;\n    \n    // Find annual return\n    const annualReturn = this.extractAnnualReturn(rows, headers);\n    \n    return {\n      monthlyNetIncome,\n      expenses,\n      totalExpenses,\n      savings,\n      savingsPercentage,\n      annualReturn\n    };\n  }\n\n  /**\n   * Extracts income information from CSV rows\n   */\n  private static extractIncome(rows: Record<string, string>[], headers: string[]): number {\n    // Look for income-related rows\n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      for (const [, value] of Object.entries(row)) {\n        if (this.FINANCIAL_PATTERNS.incomePatterns.some(pattern => pattern.test(value))) {\n          // Look for amount in the same row first\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) return amount;\n          \n          // Check next row if current row doesn't have amount\n          if (i + 1 < rows.length) {\n            const nextRow = rows[i + 1];\n            const nextAmount = this.findAmountInRow(nextRow, headers);\n            if (nextAmount > 0) return nextAmount;\n          }\n        }\n      }\n    }\n    \n    return 0;\n  }\n\n  /**\n   * Extracts expense information from CSV rows\n   */\n  private static extractExpenses(rows: Record<string, string>[], headers: string[]): Expense[] {\n    const expenses: Expense[] = [];\n    \n    for (const row of rows) {\n      // Look for expense categories in any column\n      for (const [, value] of Object.entries(row)) {\n        if (value && this.isExpenseCategory(value)) {\n          // Found an expense category, look for amount in the same row\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) {\n            const normalizedCategory = this.normalizeExpenseCategory(value.trim());\n            expenses.push({ category: normalizedCategory, amount });\n          }\n        }\n      }\n    }\n    \n    return expenses;\n  }\n\n  /**\n   * Extracts annual return percentage\n   */\n  private static extractAnnualReturn(rows: Record<string, string>[], headers: string[]): number {\n    for (const row of rows) {\n      for (const [, value] of Object.entries(row)) {\n        if (/annual.*return|return.*annual/i.test(value)) {\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) return amount;\n        }\n      }\n    }\n    \n    return 7; // Default 7% return\n  }\n\n  /**\n   * Finds category/description in a row\n   */\n  private static findCategoryInRow(row: Record<string, string>, headers: string[]): string | null {\n    for (const [, value] of Object.entries(row)) {\n      if (value && \n          !this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(value)) &&\n          !this.FINANCIAL_PATTERNS.datePatterns.some(p => p.test(value)) &&\n          value.length > 1) {\n        return value.trim();\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Finds amount in a row\n   */\n  private static findAmountInRow(row: Record<string, string>, headers: string[]): number {\n    for (const [, value] of Object.entries(row)) {\n      if (value && this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(value))) {\n        const cleaned = value.replace(/[$,%\\s]/g, '');\n        const parsed = parseFloat(cleaned);\n        if (!isNaN(parsed)) {\n          return parsed;\n        }\n      }\n    }\n    \n    // Also check for amounts that might be in the same cell as text\n    for (const [, value] of Object.entries(row)) {\n      if (value) {\n        // Look for dollar amounts in the text\n        const dollarMatch = value.match(/\\$\\s*[\\d,]+\\.?\\d*/);\n        if (dollarMatch) {\n          const cleaned = dollarMatch[0].replace(/[$,%\\s]/g, '');\n          const parsed = parseFloat(cleaned);\n          if (!isNaN(parsed)) {\n            return parsed;\n          }\n        }\n      }\n    }\n    \n    return 0;\n  }\n\n  /**\n   * Checks if a category is an expense category\n   */\n  private static isExpenseCategory(category: string): boolean {\n    return this.FINANCIAL_PATTERNS.expensePatterns.some(pattern => pattern.test(category));\n  }\n\n  /**\n   * Normalizes expense category names to handle misspellings and variations\n   */\n  private static normalizeExpenseCategory(category: string): string {\n    const normalized = category.toLowerCase().trim();\n    \n    // Check against known variations\n    for (const [standardName, variations] of Object.entries(this.EXPENSE_VARIATIONS)) {\n      if (variations.some(variation => variation.toLowerCase() === normalized)) {\n        return standardName;\n      }\n    }\n    \n    // Try fuzzy matching for close misspellings\n    const fuzzyMatch = this.findFuzzyMatch(normalized);\n    if (fuzzyMatch) {\n      return fuzzyMatch;\n    }\n    \n    // If no variation found, return the original category\n    return category;\n  }\n\n  /**\n   * Finds fuzzy matches for expense categories using simple string similarity\n   */\n  private static findFuzzyMatch(category: string): string | null {\n    const standardCategories = Object.keys(this.EXPENSE_VARIATIONS);\n    \n    for (const standard of standardCategories) {\n      if (this.calculateSimilarity(category, standard) > 0.8) {\n        return standard;\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Calculates string similarity using Levenshtein distance\n   */\n  private static calculateSimilarity(str1: string, str2: string): number {\n    const longer = str1.length > str2.length ? str1 : str2;\n    const shorter = str1.length > str2.length ? str2 : str1;\n    \n    if (longer.length === 0) return 1.0;\n    \n    const distance = this.levenshteinDistance(longer, shorter);\n    return (longer.length - distance) / longer.length;\n  }\n\n  /**\n   * Calculates Levenshtein distance between two strings\n   */\n  private static levenshteinDistance(str1: string, str2: string): number {\n    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));\n    \n    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;\n    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;\n    \n    for (let j = 1; j <= str2.length; j++) {\n      for (let i = 1; i <= str1.length; i++) {\n        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\n        matrix[j][i] = Math.min(\n          matrix[j][i - 1] + 1,     // deletion\n          matrix[j - 1][i] + 1,     // insertion\n          matrix[j - 1][i - 1] + indicator // substitution\n        );\n      }\n    }\n    \n    return matrix[str2.length][str1.length];\n  }\n\n  /**\n   * Validates and cleans CSV content\n   */\n  static validateAndCleanCSV(csvContent: string): { isValid: boolean; cleanedContent: string; errors: string[] } {\n    const errors: string[] = [];\n    let cleanedContent = csvContent;\n\n    try {\n      // Basic validation\n      if (!csvContent || csvContent.trim().length === 0) {\n        errors.push('CSV content is empty');\n        return { isValid: false, cleanedContent: '', errors };\n      }\n\n      // Try to parse and re-serialize to clean up formatting\n      const results = Papa.parse<string[]>(csvContent, {\n        header: false,\n        skipEmptyLines: true,\n        transform: (value: string) => value?.trim() || ''\n      });\n\n      if (results.errors.length > 0) {\n        errors.push(...results.errors.map(e => e.message));\n      }\n\n      // Re-serialize to ensure consistent formatting\n      cleanedContent = Papa.unparse(results.data);\n\n      return {\n        isValid: errors.length === 0,\n        cleanedContent,\n        errors\n      };\n    } catch (error) {\n      errors.push(`Failed to parse CSV: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return { isValid: false, cleanedContent: '', errors };\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}