{"ast":null,"code":"import Papa from 'papaparse';\nexport class CSVStandardizer {\n  /**\n   * Standardizes CSV data by detecting headers and normalizing the structure\n   */\n  static standardizeCSV(csvContent) {\n    const results = Papa.parse(csvContent, {\n      header: false,\n      skipEmptyLines: true,\n      transform: value => (value === null || value === void 0 ? void 0 : value.trim()) || '',\n      // Handle quoted values properly\n      quotes: true,\n      quoteChar: '\"',\n      escapeChar: '\"'\n    });\n    const data = results.data;\n    if (data.length === 0) {\n      return {\n        headers: [],\n        rows: [],\n        rawData: []\n      };\n    }\n\n    // Detect header row (usually first non-empty row)\n    const headerRow = this.detectHeaderRow(data);\n    const headers = this.normalizeHeaders(data[headerRow] || []);\n\n    // Extract data rows\n    const dataRows = data.slice(headerRow + 1);\n    const rows = dataRows.map(row => {\n      const rowObj = {};\n      headers.forEach((header, index) => {\n        rowObj[header] = row[index] || '';\n      });\n      return rowObj;\n    });\n    return {\n      headers,\n      rows,\n      rawData: data\n    };\n  }\n\n  /**\n   * Detects which row contains the headers\n   */\n  static detectHeaderRow(data) {\n    // For most CSVs, the first row is the header\n    // But we can also look for patterns that suggest header rows\n    let bestHeaderRow = 0;\n    let maxTextScore = 0;\n    for (let i = 0; i < Math.min(3, data.length); i++) {\n      const row = data[i];\n      let textScore = 0;\n      for (const cell of row) {\n        if (cell && typeof cell === 'string') {\n          // Score based on text characteristics\n          if (this.FINANCIAL_PATTERNS.incomePatterns.some(p => p.test(cell))) textScore += 3;\n          if (this.FINANCIAL_PATTERNS.expensePatterns.some(p => p.test(cell))) textScore += 2;\n          if (!this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(cell))) textScore += 1;\n          if (cell.length > 3 && !/^\\d+$/.test(cell)) textScore += 1;\n          // Bonus for common header words\n          if (/date|category|amount|description|type/i.test(cell)) textScore += 2;\n        }\n      }\n      if (textScore > maxTextScore) {\n        maxTextScore = textScore;\n        bestHeaderRow = i;\n      }\n    }\n    return bestHeaderRow;\n  }\n\n  /**\n   * Normalizes headers to standard format\n   */\n  static normalizeHeaders(headers) {\n    return headers.map((header, index) => {\n      if (!header || header.trim() === '') {\n        return `column_${index + 1}`;\n      }\n\n      // Clean and normalize header\n      let normalized = header.toLowerCase().replace(/[^\\w\\s]/g, '').replace(/\\s+/g, '_').trim();\n\n      // Map common variations to standard names\n      const headerMappings = {\n        'booba_money': 'category',\n        'booboo_moeny': 'amount',\n        'baobooboo_money': 'running_total',\n        'date': 'date',\n        'description': 'description',\n        'category': 'category',\n        'amount': 'amount',\n        'value': 'amount',\n        'cost': 'amount',\n        'price': 'amount'\n      };\n      return headerMappings[normalized] || normalized;\n    });\n  }\n\n  /**\n   * Extracts financial data from standardized CSV\n   */\n  static extractFinancialData(standardizedData) {\n    const {\n      headers,\n      rows\n    } = standardizedData;\n\n    // Find income data\n    const monthlyNetIncome = this.extractIncome(rows, headers);\n\n    // Find expense data\n    const expenses = this.extractExpenses(rows, headers);\n    const totalExpenses = expenses.reduce((sum, expense) => sum + expense.amount, 0);\n\n    // Calculate savings\n    const savings = monthlyNetIncome - totalExpenses;\n    const savingsPercentage = monthlyNetIncome > 0 ? savings / monthlyNetIncome * 100 : 0;\n\n    // Find annual return\n    const annualReturn = this.extractAnnualReturn(rows, headers);\n    return {\n      monthlyNetIncome,\n      expenses,\n      totalExpenses,\n      savings,\n      savingsPercentage,\n      annualReturn\n    };\n  }\n\n  /**\n   * Extracts income information from CSV rows\n   */\n  static extractIncome(rows, headers) {\n    // Look for income-related rows\n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      for (const [, value] of Object.entries(row)) {\n        if (this.FINANCIAL_PATTERNS.incomePatterns.some(pattern => pattern.test(value))) {\n          // Look for amount in the same row first\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) return amount;\n\n          // Check next row if current row doesn't have amount\n          if (i + 1 < rows.length) {\n            const nextRow = rows[i + 1];\n            const nextAmount = this.findAmountInRow(nextRow, headers);\n            if (nextAmount > 0) return nextAmount;\n          }\n        }\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Extracts expense information from CSV rows\n   */\n  static extractExpenses(rows, headers) {\n    const expenses = [];\n    for (const row of rows) {\n      // Look for expense categories in any column\n      for (const [key, value] of Object.entries(row)) {\n        if (value && this.isExpenseCategory(value)) {\n          // Found an expense category, look for amount in the same row\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) {\n            expenses.push({\n              category: value.trim(),\n              amount\n            });\n          }\n        }\n      }\n    }\n    return expenses;\n  }\n\n  /**\n   * Extracts annual return percentage\n   */\n  static extractAnnualReturn(rows, headers) {\n    for (const row of rows) {\n      for (const [key, value] of Object.entries(row)) {\n        if (/annual.*return|return.*annual/i.test(value)) {\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) return amount;\n        }\n      }\n    }\n    return 7; // Default 7% return\n  }\n\n  /**\n   * Finds category/description in a row\n   */\n  static findCategoryInRow(row, headers) {\n    for (const [key, value] of Object.entries(row)) {\n      if (value && !this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(value)) && !this.FINANCIAL_PATTERNS.datePatterns.some(p => p.test(value)) && value.length > 1) {\n        return value.trim();\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Finds amount in a row\n   */\n  static findAmountInRow(row, headers) {\n    for (const [key, value] of Object.entries(row)) {\n      if (value && this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(value))) {\n        const cleaned = value.replace(/[$,%\\s]/g, '');\n        const parsed = parseFloat(cleaned);\n        if (!isNaN(parsed)) {\n          return parsed;\n        }\n      }\n    }\n\n    // Also check for amounts that might be in the same cell as text\n    for (const [key, value] of Object.entries(row)) {\n      if (value) {\n        // Look for dollar amounts in the text\n        const dollarMatch = value.match(/\\$\\s*[\\d,]+\\.?\\d*/);\n        if (dollarMatch) {\n          const cleaned = dollarMatch[0].replace(/[$,%\\s]/g, '');\n          const parsed = parseFloat(cleaned);\n          if (!isNaN(parsed)) {\n            return parsed;\n          }\n        }\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Checks if a category is an expense category\n   */\n  static isExpenseCategory(category) {\n    return this.FINANCIAL_PATTERNS.expensePatterns.some(pattern => pattern.test(category));\n  }\n\n  /**\n   * Validates and cleans CSV content\n   */\n  static validateAndCleanCSV(csvContent) {\n    const errors = [];\n    let cleanedContent = csvContent;\n    try {\n      // Basic validation\n      if (!csvContent || csvContent.trim().length === 0) {\n        errors.push('CSV content is empty');\n        return {\n          isValid: false,\n          cleanedContent: '',\n          errors\n        };\n      }\n\n      // Try to parse and re-serialize to clean up formatting\n      const results = Papa.parse(csvContent, {\n        header: false,\n        skipEmptyLines: true,\n        transform: value => (value === null || value === void 0 ? void 0 : value.trim()) || ''\n      });\n      if (results.errors.length > 0) {\n        errors.push(...results.errors.map(e => e.message));\n      }\n\n      // Re-serialize to ensure consistent formatting\n      cleanedContent = Papa.unparse(results.data);\n      return {\n        isValid: errors.length === 0,\n        cleanedContent,\n        errors\n      };\n    } catch (error) {\n      errors.push(`Failed to parse CSV: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return {\n        isValid: false,\n        cleanedContent: '',\n        errors\n      };\n    }\n  }\n}\nCSVStandardizer.FINANCIAL_PATTERNS = {\n  incomePatterns: [/income/i, /salary/i, /wage/i, /earnings/i, /revenue/i, /net income/i, /monthly income/i, /annual income/i, /gross income/i, /take home/i],\n  expensePatterns: [/expense/i, /cost/i, /spending/i, /payment/i, /bill/i, /rent/i, /utilities/i, /groceries/i, /food/i, /restaurant/i, /gas/i, /auto/i, /car/i, /medical/i, /health/i, /gym/i, /travel/i, /shopping/i, /entertainment/i, /fun/i, /misc/i, /miscellaneous/i],\n  amountPatterns: [/^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*$/, /^\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/, /^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/],\n  datePatterns: [/^\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}$/, /^\\d{4}-\\d{1,2}-\\d{1,2}$/, /^\\d{1,2}-\\d{1,2}-\\d{2,4}$/]\n};","map":{"version":3,"names":["Papa","CSVStandardizer","standardizeCSV","csvContent","results","parse","header","skipEmptyLines","transform","value","trim","quotes","quoteChar","escapeChar","data","length","headers","rows","rawData","headerRow","detectHeaderRow","normalizeHeaders","dataRows","slice","map","row","rowObj","forEach","index","bestHeaderRow","maxTextScore","i","Math","min","textScore","cell","FINANCIAL_PATTERNS","incomePatterns","some","p","test","expensePatterns","amountPatterns","normalized","toLowerCase","replace","headerMappings","extractFinancialData","standardizedData","monthlyNetIncome","extractIncome","expenses","extractExpenses","totalExpenses","reduce","sum","expense","amount","savings","savingsPercentage","annualReturn","extractAnnualReturn","Object","entries","pattern","findAmountInRow","nextRow","nextAmount","key","isExpenseCategory","push","category","findCategoryInRow","datePatterns","cleaned","parsed","parseFloat","isNaN","dollarMatch","match","validateAndCleanCSV","errors","cleanedContent","isValid","e","message","unparse","error","Error"],"sources":["/home/tanged/repo/Fortuna/src/utils/csvStandardizer.ts"],"sourcesContent":["import Papa from 'papaparse';\nimport { ParsedFinancialData, Expense } from '../types/finance';\n\nexport interface StandardizedCSVData {\n  headers: string[];\n  rows: Record<string, string>[];\n  rawData: any[];\n}\n\nexport interface FinancialDataPattern {\n  incomePatterns: RegExp[];\n  expensePatterns: RegExp[];\n  amountPatterns: RegExp[];\n  datePatterns: RegExp[];\n}\n\nexport class CSVStandardizer {\n  private static readonly FINANCIAL_PATTERNS: FinancialDataPattern = {\n    incomePatterns: [\n      /income/i,\n      /salary/i,\n      /wage/i,\n      /earnings/i,\n      /revenue/i,\n      /net income/i,\n      /monthly income/i,\n      /annual income/i,\n      /gross income/i,\n      /take home/i\n    ],\n    expensePatterns: [\n      /expense/i,\n      /cost/i,\n      /spending/i,\n      /payment/i,\n      /bill/i,\n      /rent/i,\n      /utilities/i,\n      /groceries/i,\n      /food/i,\n      /restaurant/i,\n      /gas/i,\n      /auto/i,\n      /car/i,\n      /medical/i,\n      /health/i,\n      /gym/i,\n      /travel/i,\n      /shopping/i,\n      /entertainment/i,\n      /fun/i,\n      /misc/i,\n      /miscellaneous/i\n    ],\n    amountPatterns: [\n      /^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*$/,\n      /^\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/,\n      /^\\s*\\$?\\s*[\\d,]+\\.?\\d*\\s*%?\\s*$/\n    ],\n    datePatterns: [\n      /^\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}$/,\n      /^\\d{4}-\\d{1,2}-\\d{1,2}$/,\n      /^\\d{1,2}-\\d{1,2}-\\d{2,4}$/\n    ]\n  };\n\n  /**\n   * Standardizes CSV data by detecting headers and normalizing the structure\n   */\n  static standardizeCSV(csvContent: string): StandardizedCSVData {\n    const results = Papa.parse<string[]>(csvContent, {\n      header: false,\n      skipEmptyLines: true,\n      transform: (value: string) => value?.trim() || '',\n      // Handle quoted values properly\n      quotes: true,\n      quoteChar: '\"',\n      escapeChar: '\"'\n    });\n\n    const data = results.data;\n    \n    if (data.length === 0) {\n      return { headers: [], rows: [], rawData: [] };\n    }\n\n    // Detect header row (usually first non-empty row)\n    const headerRow = this.detectHeaderRow(data);\n    const headers = this.normalizeHeaders(data[headerRow] || []);\n    \n    // Extract data rows\n    const dataRows = data.slice(headerRow + 1);\n    const rows = dataRows.map(row => {\n      const rowObj: Record<string, string> = {};\n      headers.forEach((header, index) => {\n        rowObj[header] = row[index] || '';\n      });\n      return rowObj;\n    });\n\n    return {\n      headers,\n      rows,\n      rawData: data\n    };\n  }\n\n  /**\n   * Detects which row contains the headers\n   */\n  private static detectHeaderRow(data: string[][]): number {\n    // For most CSVs, the first row is the header\n    // But we can also look for patterns that suggest header rows\n    let bestHeaderRow = 0;\n    let maxTextScore = 0;\n\n    for (let i = 0; i < Math.min(3, data.length); i++) {\n      const row = data[i];\n      let textScore = 0;\n      \n      for (const cell of row) {\n        if (cell && typeof cell === 'string') {\n          // Score based on text characteristics\n          if (this.FINANCIAL_PATTERNS.incomePatterns.some(p => p.test(cell))) textScore += 3;\n          if (this.FINANCIAL_PATTERNS.expensePatterns.some(p => p.test(cell))) textScore += 2;\n          if (!this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(cell))) textScore += 1;\n          if (cell.length > 3 && !/^\\d+$/.test(cell)) textScore += 1;\n          // Bonus for common header words\n          if (/date|category|amount|description|type/i.test(cell)) textScore += 2;\n        }\n      }\n      \n      if (textScore > maxTextScore) {\n        maxTextScore = textScore;\n        bestHeaderRow = i;\n      }\n    }\n\n    return bestHeaderRow;\n  }\n\n  /**\n   * Normalizes headers to standard format\n   */\n  private static normalizeHeaders(headers: string[]): string[] {\n    return headers.map((header, index) => {\n      if (!header || header.trim() === '') {\n        return `column_${index + 1}`;\n      }\n      \n      // Clean and normalize header\n      let normalized = header.toLowerCase()\n        .replace(/[^\\w\\s]/g, '')\n        .replace(/\\s+/g, '_')\n        .trim();\n      \n      // Map common variations to standard names\n      const headerMappings: Record<string, string> = {\n        'booba_money': 'category',\n        'booboo_moeny': 'amount',\n        'baobooboo_money': 'running_total',\n        'date': 'date',\n        'description': 'description',\n        'category': 'category',\n        'amount': 'amount',\n        'value': 'amount',\n        'cost': 'amount',\n        'price': 'amount'\n      };\n      \n      return headerMappings[normalized] || normalized;\n    });\n  }\n\n  /**\n   * Extracts financial data from standardized CSV\n   */\n  static extractFinancialData(standardizedData: StandardizedCSVData): ParsedFinancialData {\n    const { headers, rows } = standardizedData;\n    \n    // Find income data\n    const monthlyNetIncome = this.extractIncome(rows, headers);\n    \n    // Find expense data\n    const expenses = this.extractExpenses(rows, headers);\n    const totalExpenses = expenses.reduce((sum, expense) => sum + expense.amount, 0);\n    \n    // Calculate savings\n    const savings = monthlyNetIncome - totalExpenses;\n    const savingsPercentage = monthlyNetIncome > 0 ? (savings / monthlyNetIncome) * 100 : 0;\n    \n    // Find annual return\n    const annualReturn = this.extractAnnualReturn(rows, headers);\n    \n    return {\n      monthlyNetIncome,\n      expenses,\n      totalExpenses,\n      savings,\n      savingsPercentage,\n      annualReturn\n    };\n  }\n\n  /**\n   * Extracts income information from CSV rows\n   */\n  private static extractIncome(rows: Record<string, string>[], headers: string[]): number {\n    // Look for income-related rows\n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      for (const [, value] of Object.entries(row)) {\n        if (this.FINANCIAL_PATTERNS.incomePatterns.some(pattern => pattern.test(value))) {\n          // Look for amount in the same row first\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) return amount;\n          \n          // Check next row if current row doesn't have amount\n          if (i + 1 < rows.length) {\n            const nextRow = rows[i + 1];\n            const nextAmount = this.findAmountInRow(nextRow, headers);\n            if (nextAmount > 0) return nextAmount;\n          }\n        }\n      }\n    }\n    \n    return 0;\n  }\n\n  /**\n   * Extracts expense information from CSV rows\n   */\n  private static extractExpenses(rows: Record<string, string>[], headers: string[]): Expense[] {\n    const expenses: Expense[] = [];\n    \n    for (const row of rows) {\n      // Look for expense categories in any column\n      for (const [key, value] of Object.entries(row)) {\n        if (value && this.isExpenseCategory(value)) {\n          // Found an expense category, look for amount in the same row\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) {\n            expenses.push({ category: value.trim(), amount });\n          }\n        }\n      }\n    }\n    \n    return expenses;\n  }\n\n  /**\n   * Extracts annual return percentage\n   */\n  private static extractAnnualReturn(rows: Record<string, string>[], headers: string[]): number {\n    for (const row of rows) {\n      for (const [key, value] of Object.entries(row)) {\n        if (/annual.*return|return.*annual/i.test(value)) {\n          const amount = this.findAmountInRow(row, headers);\n          if (amount > 0) return amount;\n        }\n      }\n    }\n    \n    return 7; // Default 7% return\n  }\n\n  /**\n   * Finds category/description in a row\n   */\n  private static findCategoryInRow(row: Record<string, string>, headers: string[]): string | null {\n    for (const [key, value] of Object.entries(row)) {\n      if (value && \n          !this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(value)) &&\n          !this.FINANCIAL_PATTERNS.datePatterns.some(p => p.test(value)) &&\n          value.length > 1) {\n        return value.trim();\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Finds amount in a row\n   */\n  private static findAmountInRow(row: Record<string, string>, headers: string[]): number {\n    for (const [key, value] of Object.entries(row)) {\n      if (value && this.FINANCIAL_PATTERNS.amountPatterns.some(p => p.test(value))) {\n        const cleaned = value.replace(/[$,%\\s]/g, '');\n        const parsed = parseFloat(cleaned);\n        if (!isNaN(parsed)) {\n          return parsed;\n        }\n      }\n    }\n    \n    // Also check for amounts that might be in the same cell as text\n    for (const [key, value] of Object.entries(row)) {\n      if (value) {\n        // Look for dollar amounts in the text\n        const dollarMatch = value.match(/\\$\\s*[\\d,]+\\.?\\d*/);\n        if (dollarMatch) {\n          const cleaned = dollarMatch[0].replace(/[$,%\\s]/g, '');\n          const parsed = parseFloat(cleaned);\n          if (!isNaN(parsed)) {\n            return parsed;\n          }\n        }\n      }\n    }\n    \n    return 0;\n  }\n\n  /**\n   * Checks if a category is an expense category\n   */\n  private static isExpenseCategory(category: string): boolean {\n    return this.FINANCIAL_PATTERNS.expensePatterns.some(pattern => pattern.test(category));\n  }\n\n  /**\n   * Validates and cleans CSV content\n   */\n  static validateAndCleanCSV(csvContent: string): { isValid: boolean; cleanedContent: string; errors: string[] } {\n    const errors: string[] = [];\n    let cleanedContent = csvContent;\n\n    try {\n      // Basic validation\n      if (!csvContent || csvContent.trim().length === 0) {\n        errors.push('CSV content is empty');\n        return { isValid: false, cleanedContent: '', errors };\n      }\n\n      // Try to parse and re-serialize to clean up formatting\n      const results = Papa.parse(csvContent, {\n        header: false,\n        skipEmptyLines: true,\n        transform: (value: string) => value?.trim() || ''\n      });\n\n      if (results.errors.length > 0) {\n        errors.push(...results.errors.map(e => e.message));\n      }\n\n      // Re-serialize to ensure consistent formatting\n      cleanedContent = Papa.unparse(results.data);\n\n      return {\n        isValid: errors.length === 0,\n        cleanedContent,\n        errors\n      };\n    } catch (error) {\n      errors.push(`Failed to parse CSV: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return { isValid: false, cleanedContent: '', errors };\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}