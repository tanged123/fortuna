{"ast":null,"code":"import { max, min, sum } from \"d3-array\";\nimport { justify } from \"./align.js\";\nimport constant from \"./constant.js\";\nfunction ascendingSourceBreadth(a, b) {\n  return ascendingBreadth(a.source, b.source) || a.index - b.index;\n}\nfunction ascendingTargetBreadth(a, b) {\n  return ascendingBreadth(a.target, b.target) || a.index - b.index;\n}\nfunction ascendingBreadth(a, b) {\n  return a.y0 - b.y0;\n}\nfunction value(d) {\n  return d.value;\n}\nfunction defaultId(d) {\n  return d.index;\n}\nfunction defaultNodes(graph) {\n  return graph.nodes;\n}\nfunction defaultLinks(graph) {\n  return graph.links;\n}\nfunction find(nodeById, id) {\n  const node = nodeById.get(id);\n  if (!node) throw new Error(\"missing: \" + id);\n  return node;\n}\nfunction computeLinkBreadths(_ref) {\n  let {\n    nodes\n  } = _ref;\n  for (const node of nodes) {\n    let y0 = node.y0;\n    let y1 = y0;\n    for (const link of node.sourceLinks) {\n      link.y0 = y0 + link.width / 2;\n      y0 += link.width;\n    }\n    for (const link of node.targetLinks) {\n      link.y1 = y1 + link.width / 2;\n      y1 += link.width;\n    }\n  }\n}\nexport default function Sankey() {\n  let x0 = 0,\n    y0 = 0,\n    x1 = 1,\n    y1 = 1; // extent\n  let dx = 24; // nodeWidth\n  let dy = 8,\n    py; // nodePadding\n  let id = defaultId;\n  let align = justify;\n  let sort;\n  let linkSort;\n  let nodes = defaultNodes;\n  let links = defaultLinks;\n  let iterations = 6;\n  function sankey() {\n    const graph = {\n      nodes: nodes.apply(null, arguments),\n      links: links.apply(null, arguments)\n    };\n    computeNodeLinks(graph);\n    computeNodeValues(graph);\n    computeNodeDepths(graph);\n    computeNodeHeights(graph);\n    computeNodeBreadths(graph);\n    computeLinkBreadths(graph);\n    return graph;\n  }\n  sankey.update = function (graph) {\n    computeLinkBreadths(graph);\n    return graph;\n  };\n  sankey.nodeId = function (_) {\n    return arguments.length ? (id = typeof _ === \"function\" ? _ : constant(_), sankey) : id;\n  };\n  sankey.nodeAlign = function (_) {\n    return arguments.length ? (align = typeof _ === \"function\" ? _ : constant(_), sankey) : align;\n  };\n  sankey.nodeSort = function (_) {\n    return arguments.length ? (sort = _, sankey) : sort;\n  };\n  sankey.nodeWidth = function (_) {\n    return arguments.length ? (dx = +_, sankey) : dx;\n  };\n  sankey.nodePadding = function (_) {\n    return arguments.length ? (dy = py = +_, sankey) : dy;\n  };\n  sankey.nodes = function (_) {\n    return arguments.length ? (nodes = typeof _ === \"function\" ? _ : constant(_), sankey) : nodes;\n  };\n  sankey.links = function (_) {\n    return arguments.length ? (links = typeof _ === \"function\" ? _ : constant(_), sankey) : links;\n  };\n  sankey.linkSort = function (_) {\n    return arguments.length ? (linkSort = _, sankey) : linkSort;\n  };\n  sankey.size = function (_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];\n  };\n  sankey.extent = function (_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];\n  };\n  sankey.iterations = function (_) {\n    return arguments.length ? (iterations = +_, sankey) : iterations;\n  };\n  function computeNodeLinks(_ref2) {\n    let {\n      nodes,\n      links\n    } = _ref2;\n    for (const [i, node] of nodes.entries()) {\n      node.index = i;\n      node.sourceLinks = [];\n      node.targetLinks = [];\n    }\n    const nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d]));\n    for (const [i, link] of links.entries()) {\n      link.index = i;\n      let {\n        source,\n        target\n      } = link;\n      if (typeof source !== \"object\") source = link.source = find(nodeById, source);\n      if (typeof target !== \"object\") target = link.target = find(nodeById, target);\n      source.sourceLinks.push(link);\n      target.targetLinks.push(link);\n    }\n    if (linkSort != null) {\n      for (const {\n        sourceLinks,\n        targetLinks\n      } of nodes) {\n        sourceLinks.sort(linkSort);\n        targetLinks.sort(linkSort);\n      }\n    }\n  }\n  function computeNodeValues(_ref3) {\n    let {\n      nodes\n    } = _ref3;\n    for (const node of nodes) {\n      node.value = node.fixedValue === undefined ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;\n    }\n  }\n  function computeNodeDepths(_ref4) {\n    let {\n      nodes\n    } = _ref4;\n    const n = nodes.length;\n    let current = new Set(nodes);\n    let next = new Set();\n    let x = 0;\n    while (current.size) {\n      for (const node of current) {\n        node.depth = x;\n        for (const {\n          target\n        } of node.sourceLinks) {\n          next.add(target);\n        }\n      }\n      if (++x > n) throw new Error(\"circular link\");\n      current = next;\n      next = new Set();\n    }\n  }\n  function computeNodeHeights(_ref5) {\n    let {\n      nodes\n    } = _ref5;\n    const n = nodes.length;\n    let current = new Set(nodes);\n    let next = new Set();\n    let x = 0;\n    while (current.size) {\n      for (const node of current) {\n        node.height = x;\n        for (const {\n          source\n        } of node.targetLinks) {\n          next.add(source);\n        }\n      }\n      if (++x > n) throw new Error(\"circular link\");\n      current = next;\n      next = new Set();\n    }\n  }\n  function computeNodeLayers(_ref6) {\n    let {\n      nodes\n    } = _ref6;\n    const x = max(nodes, d => d.depth) + 1;\n    const kx = (x1 - x0 - dx) / (x - 1);\n    const columns = new Array(x);\n    for (const node of nodes) {\n      const i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));\n      node.layer = i;\n      node.x0 = x0 + i * kx;\n      node.x1 = node.x0 + dx;\n      if (columns[i]) columns[i].push(node);else columns[i] = [node];\n    }\n    if (sort) for (const column of columns) {\n      column.sort(sort);\n    }\n    return columns;\n  }\n  function initializeNodeBreadths(columns) {\n    const ky = min(columns, c => (y1 - y0 - (c.length - 1) * py) / sum(c, value));\n    for (const nodes of columns) {\n      let y = y0;\n      for (const node of nodes) {\n        node.y0 = y;\n        node.y1 = y + node.value * ky;\n        y = node.y1 + py;\n        for (const link of node.sourceLinks) {\n          link.width = link.value * ky;\n        }\n      }\n      y = (y1 - y + py) / (nodes.length + 1);\n      for (let i = 0; i < nodes.length; ++i) {\n        const node = nodes[i];\n        node.y0 += y * (i + 1);\n        node.y1 += y * (i + 1);\n      }\n      reorderLinks(nodes);\n    }\n  }\n  function computeNodeBreadths(graph) {\n    const columns = computeNodeLayers(graph);\n    py = Math.min(dy, (y1 - y0) / (max(columns, c => c.length) - 1));\n    initializeNodeBreadths(columns);\n    for (let i = 0; i < iterations; ++i) {\n      const alpha = Math.pow(0.99, i);\n      const beta = Math.max(1 - alpha, (i + 1) / iterations);\n      relaxRightToLeft(columns, alpha, beta);\n      relaxLeftToRight(columns, alpha, beta);\n    }\n  }\n\n  // Reposition each node based on its incoming (target) links.\n  function relaxLeftToRight(columns, alpha, beta) {\n    for (let i = 1, n = columns.length; i < n; ++i) {\n      const column = columns[i];\n      for (const target of column) {\n        let y = 0;\n        let w = 0;\n        for (const {\n          source,\n          value\n        } of target.targetLinks) {\n          let v = value * (target.layer - source.layer);\n          y += targetTop(source, target) * v;\n          w += v;\n        }\n        if (!(w > 0)) continue;\n        let dy = (y / w - target.y0) * alpha;\n        target.y0 += dy;\n        target.y1 += dy;\n        reorderNodeLinks(target);\n      }\n      if (sort === undefined) column.sort(ascendingBreadth);\n      resolveCollisions(column, beta);\n    }\n  }\n\n  // Reposition each node based on its outgoing (source) links.\n  function relaxRightToLeft(columns, alpha, beta) {\n    for (let n = columns.length, i = n - 2; i >= 0; --i) {\n      const column = columns[i];\n      for (const source of column) {\n        let y = 0;\n        let w = 0;\n        for (const {\n          target,\n          value\n        } of source.sourceLinks) {\n          let v = value * (target.layer - source.layer);\n          y += sourceTop(source, target) * v;\n          w += v;\n        }\n        if (!(w > 0)) continue;\n        let dy = (y / w - source.y0) * alpha;\n        source.y0 += dy;\n        source.y1 += dy;\n        reorderNodeLinks(source);\n      }\n      if (sort === undefined) column.sort(ascendingBreadth);\n      resolveCollisions(column, beta);\n    }\n  }\n  function resolveCollisions(nodes, alpha) {\n    const i = nodes.length >> 1;\n    const subject = nodes[i];\n    resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);\n    resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);\n    resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);\n    resolveCollisionsTopToBottom(nodes, y0, 0, alpha);\n  }\n\n  // Push any overlapping nodes down.\n  function resolveCollisionsTopToBottom(nodes, y, i, alpha) {\n    for (; i < nodes.length; ++i) {\n      const node = nodes[i];\n      const dy = (y - node.y0) * alpha;\n      if (dy > 1e-6) node.y0 += dy, node.y1 += dy;\n      y = node.y1 + py;\n    }\n  }\n\n  // Push any overlapping nodes up.\n  function resolveCollisionsBottomToTop(nodes, y, i, alpha) {\n    for (; i >= 0; --i) {\n      const node = nodes[i];\n      const dy = (node.y1 - y) * alpha;\n      if (dy > 1e-6) node.y0 -= dy, node.y1 -= dy;\n      y = node.y0 - py;\n    }\n  }\n  function reorderNodeLinks(_ref7) {\n    let {\n      sourceLinks,\n      targetLinks\n    } = _ref7;\n    if (linkSort === undefined) {\n      for (const {\n        source: {\n          sourceLinks\n        }\n      } of targetLinks) {\n        sourceLinks.sort(ascendingTargetBreadth);\n      }\n      for (const {\n        target: {\n          targetLinks\n        }\n      } of sourceLinks) {\n        targetLinks.sort(ascendingSourceBreadth);\n      }\n    }\n  }\n  function reorderLinks(nodes) {\n    if (linkSort === undefined) {\n      for (const {\n        sourceLinks,\n        targetLinks\n      } of nodes) {\n        sourceLinks.sort(ascendingTargetBreadth);\n        targetLinks.sort(ascendingSourceBreadth);\n      }\n    }\n  }\n\n  // Returns the target.y0 that would produce an ideal link from source to target.\n  function targetTop(source, target) {\n    let y = source.y0 - (source.sourceLinks.length - 1) * py / 2;\n    for (const {\n      target: node,\n      width\n    } of source.sourceLinks) {\n      if (node === target) break;\n      y += width + py;\n    }\n    for (const {\n      source: node,\n      width\n    } of target.targetLinks) {\n      if (node === source) break;\n      y -= width;\n    }\n    return y;\n  }\n\n  // Returns the source.y0 that would produce an ideal link from source to target.\n  function sourceTop(source, target) {\n    let y = target.y0 - (target.targetLinks.length - 1) * py / 2;\n    for (const {\n      source: node,\n      width\n    } of target.targetLinks) {\n      if (node === source) break;\n      y += width + py;\n    }\n    for (const {\n      target: node,\n      width\n    } of source.sourceLinks) {\n      if (node === target) break;\n      y -= width;\n    }\n    return y;\n  }\n  return sankey;\n}","map":{"version":3,"names":["max","min","sum","justify","constant","ascendingSourceBreadth","a","b","ascendingBreadth","source","index","ascendingTargetBreadth","target","y0","value","d","defaultId","defaultNodes","graph","nodes","defaultLinks","links","find","nodeById","id","node","get","Error","computeLinkBreadths","_ref","y1","link","sourceLinks","width","targetLinks","Sankey","x0","x1","dx","dy","py","align","sort","linkSort","iterations","sankey","apply","arguments","computeNodeLinks","computeNodeValues","computeNodeDepths","computeNodeHeights","computeNodeBreadths","update","nodeId","_","length","nodeAlign","nodeSort","nodeWidth","nodePadding","size","extent","_ref2","i","entries","Map","map","push","_ref3","fixedValue","undefined","Math","_ref4","n","current","Set","next","x","depth","add","_ref5","height","computeNodeLayers","_ref6","kx","columns","Array","floor","call","layer","column","initializeNodeBreadths","ky","c","y","reorderLinks","alpha","pow","beta","relaxRightToLeft","relaxLeftToRight","w","v","targetTop","reorderNodeLinks","resolveCollisions","sourceTop","subject","resolveCollisionsBottomToTop","resolveCollisionsTopToBottom","_ref7"],"sources":["/home/tanged/repo/Fortuna/node_modules/d3-sankey/src/sankey.js"],"sourcesContent":["import {max, min, sum} from \"d3-array\";\nimport {justify} from \"./align.js\";\nimport constant from \"./constant.js\";\n\nfunction ascendingSourceBreadth(a, b) {\n  return ascendingBreadth(a.source, b.source) || a.index - b.index;\n}\n\nfunction ascendingTargetBreadth(a, b) {\n  return ascendingBreadth(a.target, b.target) || a.index - b.index;\n}\n\nfunction ascendingBreadth(a, b) {\n  return a.y0 - b.y0;\n}\n\nfunction value(d) {\n  return d.value;\n}\n\nfunction defaultId(d) {\n  return d.index;\n}\n\nfunction defaultNodes(graph) {\n  return graph.nodes;\n}\n\nfunction defaultLinks(graph) {\n  return graph.links;\n}\n\nfunction find(nodeById, id) {\n  const node = nodeById.get(id);\n  if (!node) throw new Error(\"missing: \" + id);\n  return node;\n}\n\nfunction computeLinkBreadths({nodes}) {\n  for (const node of nodes) {\n    let y0 = node.y0;\n    let y1 = y0;\n    for (const link of node.sourceLinks) {\n      link.y0 = y0 + link.width / 2;\n      y0 += link.width;\n    }\n    for (const link of node.targetLinks) {\n      link.y1 = y1 + link.width / 2;\n      y1 += link.width;\n    }\n  }\n}\n\nexport default function Sankey() {\n  let x0 = 0, y0 = 0, x1 = 1, y1 = 1; // extent\n  let dx = 24; // nodeWidth\n  let dy = 8, py; // nodePadding\n  let id = defaultId;\n  let align = justify;\n  let sort;\n  let linkSort;\n  let nodes = defaultNodes;\n  let links = defaultLinks;\n  let iterations = 6;\n\n  function sankey() {\n    const graph = {nodes: nodes.apply(null, arguments), links: links.apply(null, arguments)};\n    computeNodeLinks(graph);\n    computeNodeValues(graph);\n    computeNodeDepths(graph);\n    computeNodeHeights(graph);\n    computeNodeBreadths(graph);\n    computeLinkBreadths(graph);\n    return graph;\n  }\n\n  sankey.update = function(graph) {\n    computeLinkBreadths(graph);\n    return graph;\n  };\n\n  sankey.nodeId = function(_) {\n    return arguments.length ? (id = typeof _ === \"function\" ? _ : constant(_), sankey) : id;\n  };\n\n  sankey.nodeAlign = function(_) {\n    return arguments.length ? (align = typeof _ === \"function\" ? _ : constant(_), sankey) : align;\n  };\n\n  sankey.nodeSort = function(_) {\n    return arguments.length ? (sort = _, sankey) : sort;\n  };\n\n  sankey.nodeWidth = function(_) {\n    return arguments.length ? (dx = +_, sankey) : dx;\n  };\n\n  sankey.nodePadding = function(_) {\n    return arguments.length ? (dy = py = +_, sankey) : dy;\n  };\n\n  sankey.nodes = function(_) {\n    return arguments.length ? (nodes = typeof _ === \"function\" ? _ : constant(_), sankey) : nodes;\n  };\n\n  sankey.links = function(_) {\n    return arguments.length ? (links = typeof _ === \"function\" ? _ : constant(_), sankey) : links;\n  };\n\n  sankey.linkSort = function(_) {\n    return arguments.length ? (linkSort = _, sankey) : linkSort;\n  };\n\n  sankey.size = function(_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];\n  };\n\n  sankey.extent = function(_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];\n  };\n\n  sankey.iterations = function(_) {\n    return arguments.length ? (iterations = +_, sankey) : iterations;\n  };\n\n  function computeNodeLinks({nodes, links}) {\n    for (const [i, node] of nodes.entries()) {\n      node.index = i;\n      node.sourceLinks = [];\n      node.targetLinks = [];\n    }\n    const nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d]));\n    for (const [i, link] of links.entries()) {\n      link.index = i;\n      let {source, target} = link;\n      if (typeof source !== \"object\") source = link.source = find(nodeById, source);\n      if (typeof target !== \"object\") target = link.target = find(nodeById, target);\n      source.sourceLinks.push(link);\n      target.targetLinks.push(link);\n    }\n    if (linkSort != null) {\n      for (const {sourceLinks, targetLinks} of nodes) {\n        sourceLinks.sort(linkSort);\n        targetLinks.sort(linkSort);\n      }\n    }\n  }\n\n  function computeNodeValues({nodes}) {\n    for (const node of nodes) {\n      node.value = node.fixedValue === undefined\n          ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value))\n          : node.fixedValue;\n    }\n  }\n\n  function computeNodeDepths({nodes}) {\n    const n = nodes.length;\n    let current = new Set(nodes);\n    let next = new Set;\n    let x = 0;\n    while (current.size) {\n      for (const node of current) {\n        node.depth = x;\n        for (const {target} of node.sourceLinks) {\n          next.add(target);\n        }\n      }\n      if (++x > n) throw new Error(\"circular link\");\n      current = next;\n      next = new Set;\n    }\n  }\n\n  function computeNodeHeights({nodes}) {\n    const n = nodes.length;\n    let current = new Set(nodes);\n    let next = new Set;\n    let x = 0;\n    while (current.size) {\n      for (const node of current) {\n        node.height = x;\n        for (const {source} of node.targetLinks) {\n          next.add(source);\n        }\n      }\n      if (++x > n) throw new Error(\"circular link\");\n      current = next;\n      next = new Set;\n    }\n  }\n\n  function computeNodeLayers({nodes}) {\n    const x = max(nodes, d => d.depth) + 1;\n    const kx = (x1 - x0 - dx) / (x - 1);\n    const columns = new Array(x);\n    for (const node of nodes) {\n      const i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));\n      node.layer = i;\n      node.x0 = x0 + i * kx;\n      node.x1 = node.x0 + dx;\n      if (columns[i]) columns[i].push(node);\n      else columns[i] = [node];\n    }\n    if (sort) for (const column of columns) {\n      column.sort(sort);\n    }\n    return columns;\n  }\n\n  function initializeNodeBreadths(columns) {\n    const ky = min(columns, c => (y1 - y0 - (c.length - 1) * py) / sum(c, value));\n    for (const nodes of columns) {\n      let y = y0;\n      for (const node of nodes) {\n        node.y0 = y;\n        node.y1 = y + node.value * ky;\n        y = node.y1 + py;\n        for (const link of node.sourceLinks) {\n          link.width = link.value * ky;\n        }\n      }\n      y = (y1 - y + py) / (nodes.length + 1);\n      for (let i = 0; i < nodes.length; ++i) {\n        const node = nodes[i];\n        node.y0 += y * (i + 1);\n        node.y1 += y * (i + 1);\n      }\n      reorderLinks(nodes);\n    }\n  }\n\n  function computeNodeBreadths(graph) {\n    const columns = computeNodeLayers(graph);\n    py = Math.min(dy, (y1 - y0) / (max(columns, c => c.length) - 1));\n    initializeNodeBreadths(columns);\n    for (let i = 0; i < iterations; ++i) {\n      const alpha = Math.pow(0.99, i);\n      const beta = Math.max(1 - alpha, (i + 1) / iterations);\n      relaxRightToLeft(columns, alpha, beta);\n      relaxLeftToRight(columns, alpha, beta);\n    }\n  }\n\n  // Reposition each node based on its incoming (target) links.\n  function relaxLeftToRight(columns, alpha, beta) {\n    for (let i = 1, n = columns.length; i < n; ++i) {\n      const column = columns[i];\n      for (const target of column) {\n        let y = 0;\n        let w = 0;\n        for (const {source, value} of target.targetLinks) {\n          let v = value * (target.layer - source.layer);\n          y += targetTop(source, target) * v;\n          w += v;\n        }\n        if (!(w > 0)) continue;\n        let dy = (y / w - target.y0) * alpha;\n        target.y0 += dy;\n        target.y1 += dy;\n        reorderNodeLinks(target);\n      }\n      if (sort === undefined) column.sort(ascendingBreadth);\n      resolveCollisions(column, beta);\n    }\n  }\n\n  // Reposition each node based on its outgoing (source) links.\n  function relaxRightToLeft(columns, alpha, beta) {\n    for (let n = columns.length, i = n - 2; i >= 0; --i) {\n      const column = columns[i];\n      for (const source of column) {\n        let y = 0;\n        let w = 0;\n        for (const {target, value} of source.sourceLinks) {\n          let v = value * (target.layer - source.layer);\n          y += sourceTop(source, target) * v;\n          w += v;\n        }\n        if (!(w > 0)) continue;\n        let dy = (y / w - source.y0) * alpha;\n        source.y0 += dy;\n        source.y1 += dy;\n        reorderNodeLinks(source);\n      }\n      if (sort === undefined) column.sort(ascendingBreadth);\n      resolveCollisions(column, beta);\n    }\n  }\n\n  function resolveCollisions(nodes, alpha) {\n    const i = nodes.length >> 1;\n    const subject = nodes[i];\n    resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);\n    resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);\n    resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);\n    resolveCollisionsTopToBottom(nodes, y0, 0, alpha);\n  }\n\n  // Push any overlapping nodes down.\n  function resolveCollisionsTopToBottom(nodes, y, i, alpha) {\n    for (; i < nodes.length; ++i) {\n      const node = nodes[i];\n      const dy = (y - node.y0) * alpha;\n      if (dy > 1e-6) node.y0 += dy, node.y1 += dy;\n      y = node.y1 + py;\n    }\n  }\n\n  // Push any overlapping nodes up.\n  function resolveCollisionsBottomToTop(nodes, y, i, alpha) {\n    for (; i >= 0; --i) {\n      const node = nodes[i];\n      const dy = (node.y1 - y) * alpha;\n      if (dy > 1e-6) node.y0 -= dy, node.y1 -= dy;\n      y = node.y0 - py;\n    }\n  }\n\n  function reorderNodeLinks({sourceLinks, targetLinks}) {\n    if (linkSort === undefined) {\n      for (const {source: {sourceLinks}} of targetLinks) {\n        sourceLinks.sort(ascendingTargetBreadth);\n      }\n      for (const {target: {targetLinks}} of sourceLinks) {\n        targetLinks.sort(ascendingSourceBreadth);\n      }\n    }\n  }\n\n  function reorderLinks(nodes) {\n    if (linkSort === undefined) {\n      for (const {sourceLinks, targetLinks} of nodes) {\n        sourceLinks.sort(ascendingTargetBreadth);\n        targetLinks.sort(ascendingSourceBreadth);\n      }\n    }\n  }\n\n  // Returns the target.y0 that would produce an ideal link from source to target.\n  function targetTop(source, target) {\n    let y = source.y0 - (source.sourceLinks.length - 1) * py / 2;\n    for (const {target: node, width} of source.sourceLinks) {\n      if (node === target) break;\n      y += width + py;\n    }\n    for (const {source: node, width} of target.targetLinks) {\n      if (node === source) break;\n      y -= width;\n    }\n    return y;\n  }\n\n  // Returns the source.y0 that would produce an ideal link from source to target.\n  function sourceTop(source, target) {\n    let y = target.y0 - (target.targetLinks.length - 1) * py / 2;\n    for (const {source: node, width} of target.targetLinks) {\n      if (node === source) break;\n      y += width + py;\n    }\n    for (const {target: node, width} of source.sourceLinks) {\n      if (node === target) break;\n      y -= width;\n    }\n    return y;\n  }\n\n  return sankey;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}